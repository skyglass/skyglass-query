package skyglass.data.service.generic.jpa;

import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaDelete;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;

import org.springframework.beans.factory.annotation.Autowired;

import skyglass.query.metadata.jpa.JpaMetadataHelper;

@SuppressWarnings("unchecked")
public abstract class BaseJpaGenericService {

	@PersistenceContext(unitName = "platform")
	protected EntityManager entityManager;

	@Autowired
	private JpaMetadataHelper jpaMetadataHelper;

	/**
	 * <p>
	 * Persist the given transient instance and add it to the datastore, first
	 * assigning a generated identifier. (Or using the current value of the
	 * identifier property if the assigned generator is used.) This operation
	 * cascades to associated instances if the association is mapped with
	 * cascade="save-update".
	 * 
	 * <p>
	 * This is different from <code>persist()</code> in that it does guarantee
	 * that the object will be assigned an identifier immediately. With
	 * <code>save()</code> a call is made to the datastore immediately if the id
	 * is generated by the datastore so that the id can be determined. With
	 * <code>persist</code> this call may not occur until flush time.
	 * 
	 * @return The id of the newly saved entity.
	 */
	protected Serializable _save(Object entity) {
		entityManager.persist(entity);
		return (Serializable) entity;
	}

	/**
	 * Persist the given transient instances and add them to the datastore,
	 * first assigning a generated identifier. (Or using the current value of
	 * the identifier property if the assigned generator is used.) This
	 * operation cascades to associated instances if the association is mapped
	 * with cascade="save-update".
	 */
	protected void _save(Object... entities) {
		for (Object entity : entities) {
			_save(entity);
		}
	}

	/**
	 * <p>
	 * Calls Hibernate's <code>saveOrUpdate()</code>, which behaves as follows:
	 * 
	 * <p>
	 * Either <code>save()</code> or <code>update()</code> based on the
	 * following rules
	 * <ul>
	 * <li>if the object is already persistent in this session, do nothing
	 * <li>if another object associated with the session has the same
	 * identifier, throw an exception
	 * <li>if the object has no identifier property, save() it
	 * <li>if the object's identifier has the value assigned to a newly
	 * instantiated object, save() it
	 * <li>if the object is versioned (by a &lt;version&gt; or
	 * &lt;timestamp&gt;), and the version property value is the same value
	 * assigned to a newly instantiated object, save() it
	 * <li>otherwise update() the object
	 * </ul>
	 */
	protected void _saveOrUpdate(Object entity) {
		entityManager.persist(entity);
	}

	/**
	 * <p>
	 * If an entity already exists in the datastore with the same id, call
	 * _update and return false (not new). If no such entity exists in the
	 * datastore, call _save() and return true (new)
	 * 
	 * @return <code>true</code> if _save(); <code>false</code> if _update().
	 */
	protected boolean _saveOrUpdateIsNew(Object entity) {
		if (entity == null)
			throw new IllegalArgumentException("attempt to saveOrUpdate with null entity");

		Serializable id = jpaMetadataHelper.getId(entity);
		if (entityManager.contains(entity))
			return false;

		if (id == null || (new Long(0)).equals(id) || !_exists(entity)) {
			_save(entity);
			return true;
		} else {
			_update(entity);
			return false;
		}
	}

	/**
	 * Either <code>save()</code> or <code>update()</code> each entity,
	 * depending on whether or not an entity with the same id already exists in
	 * the datastore.
	 * 
	 * @return an boolean array corresponding to to the input list of entities.
	 *         Each element is <code>true</code> if the corresponding entity was
	 *         <code>_save()</code>d or <code>false</code> if it was
	 *         <code>_update()</code>d.
	 */
	protected boolean[] _saveOrUpdateIsNew(Object... entities) {
		Boolean[] exists = new Boolean[entities.length];

		// if an entity is contained in the session, it exists; if it has no id,
		// it does not exist
		for (int i = 0; i < entities.length; i++) {
			if (entities[i] == null) {
				throw new IllegalArgumentException("attempt to saveOrUpdate with null entity");
			}
			if (entityManager.contains(entities[i])) {
				exists[i] = true;
			} else {
				Serializable id = jpaMetadataHelper.getId(entities[i]);
				if (id == null || (new Long(0)).equals(id)) {
					exists[i] = false;
				}
			}
		}

		// if it has an id and is not contained in the session, it may exist
		Map<Class<?>, List<Integer>> mayExist = new HashMap<Class<?>, List<Integer>>();
		for (int i = 0; i < entities.length; i++) {
			if (exists[i] == null) {
				Class<?> entityClass = jpaMetadataHelper.getUnproxiedClass(entities[i]); // Get
																							// the
																							// real
																							// entity
																							// class
				List<Integer> l = mayExist.get(entityClass);
				if (l == null) {
					l = new ArrayList<Integer>();
					mayExist.put(entityClass, l);
				}
				l.add(i);
			}
		}

		// for each type of entity, do a batch call to the datastore to see
		// which of the entities of that class exist
		for (Map.Entry<Class<?>, List<Integer>> entry : mayExist.entrySet()) {
			Serializable[] ids = new Serializable[entry.getValue().size()];
			for (int i = 0; i < ids.length; i++) {
				ids[i] = jpaMetadataHelper.getId(entities[entry.getValue().get(i)]);
			}
			boolean exists2[] = _exists(entry.getKey(), ids);
			for (int i = 0; i < ids.length; i++) {
				exists[entry.getValue().get(i)] = exists2[i];
			}
		}

		boolean[] isNew = new boolean[entities.length];
		// now that we know which ones exist, save or update each.
		for (int i = 0; i < entities.length; i++) {
			if (entities[i] != null) {
				if (exists[i]) {
					_update(entities[i]);
					isNew[i] = false;
				} else {
					_save(entities[i]);
					isNew[i] = true;
				}
			}
		}

		return isNew;
	}

	/**
	 * <p>
	 * Make a transient instance persistent and add it to the datastore. This
	 * operation cascades to associated instances if the association is mapped
	 * with cascade="persist". Throws an error if the entity already exists.
	 * 
	 * <p>
	 * This is different from <code>save()</code> in that it does not guarantee
	 * that the object will be assigned an identifier immediately. With
	 * <code>save()</code> a call is made to the datastore immediately if the id
	 * is generated by the datastore so that the id can be determined. With
	 * <code>persist</code> this call may not occur until flush time.
	 */
	protected void _persist(Object... entities) {
		for (Object entity : entities) {
			entityManager.persist(entity);
		}
	}

	/**
	 * Remove the entity of the specified class with the specified id from the
	 * datastore.
	 * 
	 * @return <code>true</code> if the object is found in the datastore and
	 *         deleted, <code>false</code> if the item is not found.
	 */
	protected boolean _deleteById(Class<?> type, Serializable id) {
		if (id != null) {
			type = jpaMetadataHelper.getUnproxiedClass(type); // Get the real
																// entity class
			Object entity = entityManager.find(type, id);
			if (entity != null) {
				entityManager.remove(entity);
				return true;
			}
		}
		return false;
	}

	/**
	 * Remove all the entities of the given type from the datastore that have
	 * one of these ids.
	 */
	@SuppressWarnings("rawtypes")
	protected void _deleteById(Class<?> type, Serializable... ids) {
		type = jpaMetadataHelper.getUnproxiedClass(type); // Get the real
															// entity
															// class
		CriteriaBuilder cb = entityManager.getCriteriaBuilder();
		// create delete
		CriteriaDelete delete = cb.createCriteriaDelete(type);
		// set the root class
		Root<?> e = delete.from(type);
		// set where clause
		delete.where(e.get("id").in((Object[]) ids));

		// perform delete
		entityManager.createQuery(delete).executeUpdate();
	}

	/**
	 * Remove the specified entity from the datastore.
	 * 
	 * @return <code>true</code> if the object is found in the datastore and
	 *         removed, <code>false</code> if the item is not found.
	 */
	protected boolean _deleteEntity(Object entity) {
		if (entity != null) {
			Serializable id = jpaMetadataHelper.getId(entity);
			if (id != null) {
				entity = entityManager.find(jpaMetadataHelper.getUnproxiedClass(entity), id);
				if (entity != null) {
					entityManager.remove(entity);
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Remove the specified entities from the datastore.
	 */
	protected void _deleteEntities(Object... entities) {
		for (Object entity : entities) {
			if (entity != null)
				entityManager.remove(entity);
		}
	}

	/**
	 * Return the persistent instance of the given entity class with the given
	 * identifier, or null if there is no such persistent instance.
	 * <code>get()</code> always hits the database immediately.
	 */
	protected <T> T _getById(Class<T> type, Serializable id) {
		type = jpaMetadataHelper.getUnproxiedClass(type); // Get the real
															// entity
															// class
		return entityManager.find(type, id);
	}

	/**
	 * <p>
	 * Return the all the persistent instances of the given entity class with
	 * the given identifiers. An array of entities is returned that matches the
	 * same order of the ids listed in the call. For each entity that is not
	 * found in the datastore, a null will be inserted in its place in the
	 * return array.
	 * 
	 * <p>
	 * <code>get()</code> always hits the database immediately.
	 */
	protected <T> T[] _getByIds(Class<T> type, Serializable... ids) {
		type = jpaMetadataHelper.getUnproxiedClass(type); // Get the real entity
															// class
		CriteriaBuilder cb = entityManager.getCriteriaBuilder();
		// create delete
		CriteriaQuery<T> query = cb.createQuery(type);
		// set the root class
		Root<?> e = query.from(type);
		// set where clause
		query.where(e.get("id").in((Object[]) ids));
		Object[] retVal = (Object[]) Array.newInstance(type, ids.length);

		for (Object entity : entityManager.createQuery(query).getResultList()) {
			Serializable id = jpaMetadataHelper.getId(entity);
			for (int i = 0; i < ids.length; i++) {
				if (id.equals(ids[i])) {
					retVal[i] = entity;
					break;
				}
			}
		}

		return (T[]) retVal;
	}

	/**
	 * <p>
	 * Return the persistent instance of the given entity class with the given
	 * identifier, assuming that the instance exists. Throw an unrecoverable
	 * exception if there is no matching database row.
	 * 
	 * <p>
	 * If the class is mapped with a proxy, <code>load()</code> just returns an
	 * uninitialized proxy and does not actually hit the database until you
	 * invoke a method of the proxy. This behaviour is very useful if you wish
	 * to create an association to an object without actually loading it from
	 * the database. It also allows multiple instances to be loaded as a batch
	 * if batch-size is defined for the class mapping.
	 */
	protected <T> T _load(Class<T> type, Serializable id) {
		type = jpaMetadataHelper.getUnproxiedClass(type); // Get the real entity
															// class
		return entityManager.getReference(type, id);
	}

	/**
	 * <p>
	 * Return the persistent instance of the given entity class with the given
	 * identifier, assuming that the instance exists. Throw an unrecoverable
	 * exception if there is no matching database row. An array of entities is
	 * returned that matches the same order of the ids listed in the call. For
	 * each entity that is not found in the datastore, a null will be inserted
	 * in its place in the return array.
	 * 
	 * @see #_load(Class, Serializable)
	 */
	protected <T> T[] _load(Class<T> type, Serializable... ids) {
		type = jpaMetadataHelper.getUnproxiedClass(type); // Get the real entity
															// class
		Object[] retVal = (Object[]) Array.newInstance(type, ids.length);
		for (int i = 0; i < ids.length; i++) {
			if (ids[i] != null)
				retVal[i] = _load(type, ids[i]);
		}
		return (T[]) retVal;
	}

	/**
	 * Get a list of all the objects of the specified class.
	 */
	protected <T> List<T> _all(Class<T> type) {
		type = jpaMetadataHelper.getUnproxiedClass(type); // Get the real entity
															// class
		CriteriaBuilder cb = entityManager.getCriteriaBuilder();
		CriteriaQuery<T> query = cb.createQuery(type).distinct(true);
		return entityManager.createQuery(query).getResultList();
	}

	/**
	 * <p>
	 * Update the persistent instance with the identifier of the given detached
	 * instance. If there is a persistent instance with the same identifier, an
	 * exception is thrown. This operation cascades to associated instances if
	 * the association is mapped with cascade="save-update".
	 * 
	 * <p>
	 * The difference between <code>update()</code> and <code>merge()</code> is
	 * significant: <code>update()</code> will make the given object persistent
	 * and throw and error if another object with the same ID is already
	 * persistent in the Session. <code>merge()</code> doesn't care if another
	 * object is already persistent, but it also doesn't make the given object
	 * persistent; it just copies over the values to the datastore.
	 */
	protected void _update(Object... transientEntities) {
		for (Object entity : transientEntities) {
			entityManager.merge(entity);
		}
	}

	/**
	 * <p>
	 * Copy the state of the given object onto the persistent object with the
	 * same identifier. If there is no persistent instance currently associated
	 * with the session, it will be loaded. Return the persistent instance. If
	 * the given instance is unsaved, save a copy of and return it as a newly
	 * persistent instance. The given instance does not become associated with
	 * the session. This operation cascades to associated instances if the
	 * association is mapped with cascade="merge".
	 * 
	 * <p>
	 * The difference between <code>update()</code> and <code>merge()</code> is
	 * significant: <code>update()</code> will make the given object persistent
	 * and throw and error if another object with the same ID is already
	 * persistent in the Session. <code>merge()</code> doesn't care if another
	 * object is already persistent, but it also doesn't make the given object
	 * persistent; it just copies over the values to the datastore.
	 */
	protected <T> T _merge(T entity) {
		return entityManager.merge(entity);
	}

	/**
	 * Returns the number of instances of this class in the datastore.
	 */
	@SuppressWarnings("rawtypes")
	protected int _count(Class<?> type) {
		List counts = entityManager.createQuery("select count(*) from " + type.getName()).getResultList();
		int sum = 0;
		for (Object count : counts) {
			sum += ((Long) count).intValue();
		}
		return sum;
	}

	/**
	 * Returns true if the object is connected to the current hibernate session.
	 */
	protected boolean _sessionContains(Object o) {
		return entityManager.contains(o);
	}

	/**
	 * Flushes changes in the hibernate cache to the datastore.
	 */
	protected void _flush() {
		entityManager.flush();
	}

	/**
	 * Refresh the content of the given entity from the current datastore state.
	 */
	protected void _refresh(Object... entities) {
		for (Object entity : entities)
			entityManager.refresh(entity);
	}

	protected boolean _exists(Object entity) {
		if (entityManager.contains(entity))
			return true;
		return _exists(entity.getClass(), jpaMetadataHelper.getId(entity));
	}

	protected boolean _exists(Class<?> type, Serializable id) {
		if (type == null)
			throw new NullPointerException("Type is null.");
		if (id == null)
			return false;
		type = jpaMetadataHelper.getUnproxiedClass(type); // Get the real entity
															// class

		Query query = entityManager.createQuery("select id from " + type.getName() + " where id = :id");
		query.setParameter("id", id);
		return query.getResultList().size() == 1;
	}

	protected <T> T _findByName(Class<T> type, String name) {
		if (type == null)
			throw new NullPointerException("Type is null.");
		if (name == null)
			return null;
		type = jpaMetadataHelper.getUnproxiedClass(type); // Get the real entity
															// class

		CriteriaBuilder cb = entityManager.getCriteriaBuilder();
		CriteriaQuery<T> query = cb.createQuery(type);
		Root<T> e = query.from(type);
		query.where(cb.equal(e.get("name"), name));
		return entityManager.createQuery(query).getSingleResult();
	}

	protected boolean[] _exists(Class<?> type, Serializable... ids) {
		if (type == null)
			throw new NullPointerException("Type is null.");
		type = jpaMetadataHelper.getUnproxiedClass(type); // Get the real entity
															// class

		boolean[] ret = new boolean[ids.length];

		// we can't use "id in (:ids)" because some databases do not support
		// this for compound ids.
		StringBuilder sb = new StringBuilder("select id from " + type.getName() + " where");
		boolean first = true;
		for (int i = 0; i < ids.length; i++) {
			if (first) {
				first = false;
				sb.append(" id = :id");
			} else {
				sb.append(" or id = :id");
			}
			sb.append(i);
		}

		Query query = entityManager.createQuery(sb.toString());
		for (int i = 0; i < ids.length; i++) {
			query.setParameter("id" + i, ids[i]);
		}

		for (Serializable id : (List<Serializable>) query.getResultList()) {
			for (int i = 0; i < ids.length; i++) {
				if (id.equals(ids[i])) {
					ret[i] = true;
					// don't break. the same id could be in the list twice.
				}
			}
		}

		return ret;
	}
}
